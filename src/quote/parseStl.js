export async function parseSTL(file,units='mm'){const ab=await file.arrayBuffer();const dv=new DataView(ab);const isAscii=(new TextDecoder().decode(ab.slice(0,512)).toLowerCase().startsWith('solid')&&new TextDecoder().decode(ab.slice(0,512)).toLowerCase().includes('facet'));let verts=[];let tris=0;if(!isAscii){if(dv.byteLength<84)throw new Error('Invalid STL');const n=dv.getUint32(80,true);let off=84;tris=n;for(let i=0;i<n;i++){off+=12;for(let v=0;v<9;v++){verts.push(dv.getFloat32(off,true));off+=4}off+=2}}else{const t=new TextDecoder().decode(ab);const lines=t.split(/\r?\n/);let cur=[];for(const line of lines){const m=line.trim().match(/^vertex\s+([\-0-9.eE]+)\s+([\-0-9.eE]+)\s+([\-0-9.eE]+)/);if(m){cur.push(parseFloat(m[1]),parseFloat(m[2]),parseFloat(m[3]));if(cur.length===9){verts.push(...cur);cur=[];tris++}}}if(tris===0)throw new Error('Could not parse ASCII STL')}let scale=1;if(units==='in')scale=25.4;for(let i=0;i<verts.length;i++)verts[i]*=scale;let min=[Infinity,Infinity,Infinity],max=[-Infinity,-Infinity,-Infinity],area=0,vol6=0;for(let i=0;i<verts.length;i+=9){const v1=[verts[i],verts[i+1],verts[i+2]],v2=[verts[i+3],verts[i+4],verts[i+5]],v3=[verts[i+6],verts[i+7],verts[i+8]];for(const v of [v1,v2,v3]){min[0]=Math.min(min[0],v[0]);min[1]=Math.min(min[1],v[1]);min[2]=Math.min(min[2],v[2]);max[0]=Math.max(max[0],v[0]);max[1]=Math.max(max[1],v[1]);max[2]=Math.max(max[2],v[2])}const a=[v2[0]-v1[0],v2[1]-v1[1],v2[2]-v1[2]],b=[v3[0]-v1[0],v3[1]-v1[1],v3[2]-v1[2]];const cross=[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];const triArea=0.5*Math.sqrt(cross[0]*cross[0]+cross[1]*cross[1]+cross[2]*cross[2]);area+=triArea;const dot=v1[0]*(v2[1]*v3[2]-v2[2]*v3[1])+v1[1]*(v2[2]*v3[0]-v2[0]*v3[2])+v1[2]*(v2[0]*v3[1]-v2[1]*v3[0]);vol6+=dot}const volume=Math.abs(vol6)/6;return{vertices:new Float32Array(verts),triangles:tris,bbox:{min,max,size_mm:[max[0]-min[0],max[1]-min[1],max[2]-min[2]]},area_cm2:area/100,volume_cc:volume/1000,z_mm:max[2]-min[2]}}